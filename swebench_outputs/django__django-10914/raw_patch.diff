diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py
index acee9887d2..d154805234 100644
--- a/django/conf/global_settings.py
+++ b/django/conf/global_settings.py
@@ -1,7 +1,11 @@
 """
+# File upload settings
+FILE_UPLOAD_PERMISSIONS = 0o644  # Unix permission bits for uploaded files
 Default Django settings. Override these with settings in the module pointed to
 by the DJANGO_SETTINGS_MODULE environment variable.
 """
+# File upload settings
+FILE_UPLOAD_PERMISSIONS = 0o644  # Unix permission bits for uploaded files
 
 
 # This is defined here as a do-nothing function because we can't import
diff --git a/django/core/files/storage.py b/django/core/files/storage.py
index cbdab1de47..49aa0953b1 100644
--- a/django/core/files/storage.py
+++ b/django/core/files/storage.py
@@ -24,23 +24,59 @@ __all__ = (
 
 class Storage:
     """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
     A base storage class, providing some default behaviors that all other
     storage systems can inherit or override, as necessary.
     """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
 
     # The following methods represent a public interface to private methods.
     # These shouldn't be overridden by subclasses unless absolutely necessary.
 
     def open(self, name, mode='rb'):
-        """Retrieve the specified file from storage."""
+        """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)Retrieve the specified file from storage."""
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         return self._open(name, mode)
 
     def save(self, name, content, max_length=None):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Save new content to the file specified by name. The content should be
         a proper File object or any Python file-like object, ready to be read
         from the beginning.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         # Get the proper name for the file, as it will actually be saved.
         if name is None:
             name = content.name
@@ -55,16 +91,40 @@ class Storage:
 
     def get_valid_name(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return a filename, based on the provided filename, that's suitable for
         use in the target storage system.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         return get_valid_filename(name)
 
     def get_available_name(self, name, max_length=None):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return a filename that's free on the target storage system and
         available for new content to be written to.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         dir_name, file_name = os.path.split(name)
         file_root, file_ext = os.path.splitext(file_name)
         # If the filename already exists, add an underscore and a random 7
@@ -93,19 +153,43 @@ class Storage:
 
     def generate_filename(self, filename):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Validate the filename by calling get_valid_name() and return a filename
         to be passed to the save() method.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         # `filename` may include a path as returned by FileField.upload_to.
         dirname, filename = os.path.split(filename)
         return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))
 
     def path(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return a local filesystem path where the file can be retrieved using
         Python's built-in open() function. Storage systems that can't be
         accessed using open() should *not* implement this method.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError("This backend doesn't support absolute paths.")
 
     # The following methods form the public API for storage systems, but with
@@ -113,64 +197,172 @@ class Storage:
 
     def delete(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Delete the specified file from the storage system.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a delete() method')
 
     def exists(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return True if a file referenced by the given name already exists in the
         storage system, or False if the name is available for a new file.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide an exists() method')
 
     def listdir(self, path):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         List the contents of the specified path. Return a 2-tuple of lists:
         the first item being directories, the second item being files.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a listdir() method')
 
     def size(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return the total size, in bytes, of the file specified by name.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a size() method')
 
     def url(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return an absolute URL where the file's contents can be accessed
         directly by a Web browser.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a url() method')
 
     def get_accessed_time(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return the last accessed time (as a datetime) of the file specified by
         name. The datetime will be timezone-aware if USE_TZ=True.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')
 
     def get_created_time(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return the creation time (as a datetime) of the file specified by name.
         The datetime will be timezone-aware if USE_TZ=True.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')
 
     def get_modified_time(self, name):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         Return the last modified time (as a datetime) of the file specified by
         name. The datetime will be timezone-aware if USE_TZ=True.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')
 
 
 @deconstructible
 class FileSystemStorage(Storage):
     """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
     Standard filesystem storage
     """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if
     # the file already exists before it's opened.
     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)
@@ -184,7 +376,19 @@ class FileSystemStorage(Storage):
         setting_changed.connect(self._clear_cached_properties)
 
     def _clear_cached_properties(self, setting, **kwargs):
-        """Reset setting based property values."""
+        """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)Reset setting based property values."""
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         if setting == 'MEDIA_ROOT':
             self.__dict__.pop('base_location', None)
             self.__dict__.pop('location', None)
@@ -329,9 +533,21 @@ class FileSystemStorage(Storage):
 
     def _datetime_from_timestamp(self, ts):
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         If timezone support is enabled, make an aware datetime object in UTC;
         otherwise make a naive one in the local timezone.
         """
+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):
+            mode = 0o644  # Default to readable files
+        else:
+            mode = settings.FILE_UPLOAD_PERMISSIONS
+        if mode is not None:
+            os.chmod(full_path, mode)
         if settings.USE_TZ:
             # Safe to use .replace() because UTC doesn't have DST
             return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)
diff --git a/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png b/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png
deleted file mode 120000
index 3f1cd17ce2..0000000000
--- a/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png
+++ /dev/null
@@ -1 +0,0 @@
-../../djangodocs/static/docicons-behindscenes.png
\ No newline at end of file
diff --git a/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png b/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png
new file mode 100644
index 0000000000..4371103c42
Binary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png differ
diff --git a/docs/_theme/djangodocs-epub/static/docicons-note.png b/docs/_theme/djangodocs-epub/static/docicons-note.png
deleted file mode 120000
index b8193a35d7..0000000000
--- a/docs/_theme/djangodocs-epub/static/docicons-note.png
+++ /dev/null
@@ -1 +0,0 @@
-../../djangodocs/static/docicons-note.png
\ No newline at end of file
diff --git a/docs/_theme/djangodocs-epub/static/docicons-note.png b/docs/_theme/djangodocs-epub/static/docicons-note.png
new file mode 100644
index 0000000000..b849019678
Binary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-note.png differ
diff --git a/docs/_theme/djangodocs-epub/static/docicons-philosophy.png b/docs/_theme/djangodocs-epub/static/docicons-philosophy.png
deleted file mode 120000
index 26d9a0c502..0000000000
--- a/docs/_theme/djangodocs-epub/static/docicons-philosophy.png
+++ /dev/null
@@ -1 +0,0 @@
-../../djangodocs/static/docicons-philosophy.png
\ No newline at end of file
diff --git a/docs/_theme/djangodocs-epub/static/docicons-philosophy.png b/docs/_theme/djangodocs-epub/static/docicons-philosophy.png
new file mode 100644
index 0000000000..a864f58f55
Binary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-philosophy.png differ
diff --git a/docs/_theme/djangodocs-epub/static/docicons-warning.png b/docs/_theme/djangodocs-epub/static/docicons-warning.png
deleted file mode 120000
index 455195f35f..0000000000
--- a/docs/_theme/djangodocs-epub/static/docicons-warning.png
+++ /dev/null
@@ -1 +0,0 @@
-../../djangodocs/static/docicons-warning.png
\ No newline at end of file
diff --git a/docs/_theme/djangodocs-epub/static/docicons-warning.png b/docs/_theme/djangodocs-epub/static/docicons-warning.png
new file mode 100644
index 0000000000..083704d50c
Binary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-warning.png differ
diff --git a/test_fix.py b/test_fix.py
new file mode 100644
index 0000000000..1270545f89
--- /dev/null
+++ b/test_fix.py
@@ -0,0 +1,62 @@
+import os
+import tempfile
+from django.core.files.storage import FileSystemStorage
+from django.core.files.uploadedfile import SimpleUploadedFile, TemporaryUploadedFile
+from django.conf import settings
+import shutil
+
+def test_file_upload_permissions():
+    # Create a temporary directory for testing
+    test_dir = tempfile.mkdtemp()
+    try:
+        # Configure storage
+        storage = FileSystemStorage(location=test_dir)
+        
+        # Test small file (will use MemoryUploadedFile)
+        small_content = b"Small file content"
+        small_file = SimpleUploadedFile("small.txt", small_content)
+        
+        # Test large file (will use TemporaryUploadedFile)
+        large_content = b"Large file content" * 1024 * 1024  # > 2.5MB to trigger TemporaryUploadedFile
+        large_file = SimpleUploadedFile("large.txt", large_content)
+        
+        # Save both files
+        small_path = storage.save("small.txt", small_file)
+        large_path = storage.save("large.txt", large_file)
+        
+        # Get full paths
+        small_full_path = os.path.join(test_dir, small_path)
+        large_full_path = os.path.join(test_dir, large_path)
+        
+        # Get permissions in octal
+        small_perms = oct(os.stat(small_full_path).st_mode & 0o777)
+        large_perms = oct(os.stat(large_full_path).st_mode & 0o777)
+        
+        # Check if permissions are different
+        if small_perms != large_perms:
+            print("Issue reproduced")
+            print(f"Small file permissions: {small_perms}")
+            print(f"Large file permissions: {large_perms}")
+            return
+        
+        # Check if both files have 0o644 permissions
+        if small_perms == oct(0o644) and large_perms == oct(0o644):
+            print("Issue resolved")
+            return
+            
+        print("Other issues")
+        
+    except Exception as e:
+        print(f"Other issues: {str(e)}")
+    finally:
+        # Clean up
+        shutil.rmtree(test_dir, ignore_errors=True)
+
+if __name__ == "__main__":
+    # Configure Django settings if not already configured
+    if not settings.configured:
+        settings.configure(
+            DEFAULT_FILE_STORAGE='django.core.files.storage.FileSystemStorage',
+        )
+    
+    test_file_upload_permissions()
\ No newline at end of file
