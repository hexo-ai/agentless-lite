{
  "instance_id": "django__django-10914",
  "patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887d2..d154805234 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -1,7 +1,11 @@\n \"\"\"\n+# File upload settings\n+FILE_UPLOAD_PERMISSIONS = 0o644  # Unix permission bits for uploaded files\n Default Django settings. Override these with settings in the module pointed to\n by the DJANGO_SETTINGS_MODULE environment variable.\n \"\"\"\n+# File upload settings\n+FILE_UPLOAD_PERMISSIONS = 0o644  # Unix permission bits for uploaded files\n \n \n # This is defined here as a do-nothing function because we can't import\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex cbdab1de47..49aa0953b1 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -24,23 +24,59 @@ __all__ = (\n \n class Storage:\n     \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n     A base storage class, providing some default behaviors that all other\n     storage systems can inherit or override, as necessary.\n     \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n \n     # The following methods represent a public interface to private methods.\n     # These shouldn't be overridden by subclasses unless absolutely necessary.\n \n     def open(self, name, mode='rb'):\n-        \"\"\"Retrieve the specified file from storage.\"\"\"\n+        \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)Retrieve the specified file from storage.\"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         return self._open(name, mode)\n \n     def save(self, name, content, max_length=None):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Save new content to the file specified by name. The content should be\n         a proper File object or any Python file-like object, ready to be read\n         from the beginning.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         # Get the proper name for the file, as it will actually be saved.\n         if name is None:\n             name = content.name\n@@ -55,16 +91,40 @@ class Storage:\n \n     def get_valid_name(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return a filename, based on the provided filename, that's suitable for\n         use in the target storage system.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         return get_valid_filename(name)\n \n     def get_available_name(self, name, max_length=None):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return a filename that's free on the target storage system and\n         available for new content to be written to.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         dir_name, file_name = os.path.split(name)\n         file_root, file_ext = os.path.splitext(file_name)\n         # If the filename already exists, add an underscore and a random 7\n@@ -93,19 +153,43 @@ class Storage:\n \n     def generate_filename(self, filename):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Validate the filename by calling get_valid_name() and return a filename\n         to be passed to the save() method.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         # `filename` may include a path as returned by FileField.upload_to.\n         dirname, filename = os.path.split(filename)\n         return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))\n \n     def path(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return a local filesystem path where the file can be retrieved using\n         Python's built-in open() function. Storage systems that can't be\n         accessed using open() should *not* implement this method.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError(\"This backend doesn't support absolute paths.\")\n \n     # The following methods form the public API for storage systems, but with\n@@ -113,64 +197,172 @@ class Storage:\n \n     def delete(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Delete the specified file from the storage system.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a delete() method')\n \n     def exists(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return True if a file referenced by the given name already exists in the\n         storage system, or False if the name is available for a new file.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide an exists() method')\n \n     def listdir(self, path):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         List the contents of the specified path. Return a 2-tuple of lists:\n         the first item being directories, the second item being files.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a listdir() method')\n \n     def size(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return the total size, in bytes, of the file specified by name.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a size() method')\n \n     def url(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return an absolute URL where the file's contents can be accessed\n         directly by a Web browser.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a url() method')\n \n     def get_accessed_time(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return the last accessed time (as a datetime) of the file specified by\n         name. The datetime will be timezone-aware if USE_TZ=True.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')\n \n     def get_created_time(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return the creation time (as a datetime) of the file specified by name.\n         The datetime will be timezone-aware if USE_TZ=True.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')\n \n     def get_modified_time(self, name):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         Return the last modified time (as a datetime) of the file specified by\n         name. The datetime will be timezone-aware if USE_TZ=True.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')\n \n \n @deconstructible\n class FileSystemStorage(Storage):\n     \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n     Standard filesystem storage\n     \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n     # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if\n     # the file already exists before it's opened.\n     OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)\n@@ -184,7 +376,19 @@ class FileSystemStorage(Storage):\n         setting_changed.connect(self._clear_cached_properties)\n \n     def _clear_cached_properties(self, setting, **kwargs):\n-        \"\"\"Reset setting based property values.\"\"\"\n+        \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)Reset setting based property values.\"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         if setting == 'MEDIA_ROOT':\n             self.__dict__.pop('base_location', None)\n             self.__dict__.pop('location', None)\n@@ -329,9 +533,21 @@ class FileSystemStorage(Storage):\n \n     def _datetime_from_timestamp(self, ts):\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         If timezone support is enabled, make an aware datetime object in UTC;\n         otherwise make a naive one in the local timezone.\n         \"\"\"\n+        if not hasattr(settings, 'FILE_UPLOAD_PERMISSIONS'):\n+            mode = 0o644  # Default to readable files\n+        else:\n+            mode = settings.FILE_UPLOAD_PERMISSIONS\n+        if mode is not None:\n+            os.chmod(full_path, mode)\n         if settings.USE_TZ:\n             # Safe to use .replace() because UTC doesn't have DST\n             return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png b/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png\ndeleted file mode 120000\nindex 3f1cd17ce2..0000000000\n--- a/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png\n+++ /dev/null\n@@ -1 +0,0 @@\n-../../djangodocs/static/docicons-behindscenes.png\n\\ No newline at end of file\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png b/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png\nnew file mode 100644\nindex 0000000000..4371103c42\nBinary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-behindscenes.png differ\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-note.png b/docs/_theme/djangodocs-epub/static/docicons-note.png\ndeleted file mode 120000\nindex b8193a35d7..0000000000\n--- a/docs/_theme/djangodocs-epub/static/docicons-note.png\n+++ /dev/null\n@@ -1 +0,0 @@\n-../../djangodocs/static/docicons-note.png\n\\ No newline at end of file\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-note.png b/docs/_theme/djangodocs-epub/static/docicons-note.png\nnew file mode 100644\nindex 0000000000..b849019678\nBinary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-note.png differ\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-philosophy.png b/docs/_theme/djangodocs-epub/static/docicons-philosophy.png\ndeleted file mode 120000\nindex 26d9a0c502..0000000000\n--- a/docs/_theme/djangodocs-epub/static/docicons-philosophy.png\n+++ /dev/null\n@@ -1 +0,0 @@\n-../../djangodocs/static/docicons-philosophy.png\n\\ No newline at end of file\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-philosophy.png b/docs/_theme/djangodocs-epub/static/docicons-philosophy.png\nnew file mode 100644\nindex 0000000000..a864f58f55\nBinary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-philosophy.png differ\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-warning.png b/docs/_theme/djangodocs-epub/static/docicons-warning.png\ndeleted file mode 120000\nindex 455195f35f..0000000000\n--- a/docs/_theme/djangodocs-epub/static/docicons-warning.png\n+++ /dev/null\n@@ -1 +0,0 @@\n-../../djangodocs/static/docicons-warning.png\n\\ No newline at end of file\ndiff --git a/docs/_theme/djangodocs-epub/static/docicons-warning.png b/docs/_theme/djangodocs-epub/static/docicons-warning.png\nnew file mode 100644\nindex 0000000000..083704d50c\nBinary files /dev/null and b/docs/_theme/djangodocs-epub/static/docicons-warning.png differ\ndiff --git a/test_fix.py b/test_fix.py\nnew file mode 100644\nindex 0000000000..1270545f89\n--- /dev/null\n+++ b/test_fix.py\n@@ -0,0 +1,62 @@\n+import os\n+import tempfile\n+from django.core.files.storage import FileSystemStorage\n+from django.core.files.uploadedfile import SimpleUploadedFile, TemporaryUploadedFile\n+from django.conf import settings\n+import shutil\n+\n+def test_file_upload_permissions():\n+    # Create a temporary directory for testing\n+    test_dir = tempfile.mkdtemp()\n+    try:\n+        # Configure storage\n+        storage = FileSystemStorage(location=test_dir)\n+        \n+        # Test small file (will use MemoryUploadedFile)\n+        small_content = b\"Small file content\"\n+        small_file = SimpleUploadedFile(\"small.txt\", small_content)\n+        \n+        # Test large file (will use TemporaryUploadedFile)\n+        large_content = b\"Large file content\" * 1024 * 1024  # > 2.5MB to trigger TemporaryUploadedFile\n+        large_file = SimpleUploadedFile(\"large.txt\", large_content)\n+        \n+        # Save both files\n+        small_path = storage.save(\"small.txt\", small_file)\n+        large_path = storage.save(\"large.txt\", large_file)\n+        \n+        # Get full paths\n+        small_full_path = os.path.join(test_dir, small_path)\n+        large_full_path = os.path.join(test_dir, large_path)\n+        \n+        # Get permissions in octal\n+        small_perms = oct(os.stat(small_full_path).st_mode & 0o777)\n+        large_perms = oct(os.stat(large_full_path).st_mode & 0o777)\n+        \n+        # Check if permissions are different\n+        if small_perms != large_perms:\n+            print(\"Issue reproduced\")\n+            print(f\"Small file permissions: {small_perms}\")\n+            print(f\"Large file permissions: {large_perms}\")\n+            return\n+        \n+        # Check if both files have 0o644 permissions\n+        if small_perms == oct(0o644) and large_perms == oct(0o644):\n+            print(\"Issue resolved\")\n+            return\n+            \n+        print(\"Other issues\")\n+        \n+    except Exception as e:\n+        print(f\"Other issues: {str(e)}\")\n+    finally:\n+        # Clean up\n+        shutil.rmtree(test_dir, ignore_errors=True)\n+\n+if __name__ == \"__main__\":\n+    # Configure Django settings if not already configured\n+    if not settings.configured:\n+        settings.configure(\n+            DEFAULT_FILE_STORAGE='django.core.files.storage.FileSystemStorage',\n+        )\n+    \n+    test_file_upload_permissions()\n\\ No newline at end of file\n",
  "model_name_or_path": "bedrock/anthropic.claude-3-5-sonnet-20241022-v2:0"
}